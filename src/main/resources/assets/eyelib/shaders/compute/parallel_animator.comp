#version 460 core

struct Pose {
    mat4 pose;
    mat3 normal;
};

struct AnimationEntry {
    vec3 bonePivot;
    vec3 position;
    vec3 rotation;
    vec3 scale;
};

layout (local_size_x = 1, local_size_y = 1) in;


layout(binding=0, std430) readonly buffer AnimationOffsets{
    int animationOffset[];
} animationOffsets;
layout (binding = 1, std430) readonly buffer Animation {
    AnimationEntry animationEntries[];
} animation;
layout (binding = 2, std430) buffer Poses {
    Pose pose[];
} poses;
layout (binding = 3, std430) readonly buffer EntityBasePose {
    Pose pose[];
} entityBasePose;

mat4 translate(vec3 pos) {
    return mat4(
            1.0f, 0.0f, 0.0f, 0.0f,
            0.0f, 1.0f, 0.0f, 0.0f,
            0.0f, 0.0f, 1.0f, 0.0f,
            pos.x, pos.y, pos.z, 1.0f
    );
}

mat4 scale(vec3 s) {
    return mat4(
            s.x, 0.0f, 0.0f, 0.0f,
            0.0f, s.y, 0.0f, 0.0f,
            0.0f, 0.0f, s.z, 0.0f,
            0.0f, 0.0f, 0.0f, 1.0f
    );
}

mat4 rotateX(float angle) {
    float s = sin(angle);
    float c = cos(angle);
    return mat4(
            1.0f, 0.0f, 0.0f, 0.0f,
            0.0f, c, s, 0.0f,
            0.0f, -s, c, 0.0f,
            0.0f, 0.0f, 0.0f, 1.0f
    );
}

mat4 rotateY(float angle) {
    float s = sin(angle);
    float c = cos(angle);
    return mat4(
            c, 0.0f, -s, 0.0f,
            0.0f, 1.0f, 0.0f, 0.0f,
            s, 0.0f, c, 0.0f,
            0.0f, 0.0f, 0.0f, 1.0f
    );
}

mat4 rotateZ(float angle) {
    float s = sin(angle);
    float c = cos(angle);
    return mat4(
            c, s, 0.0f, 0.0f,
            -s, c, 0.0f, 0.0f,
            0.0f, 0.0f, 1.0f, 0.0f,
            0.0f, 0.0f, 0.0f, 1.0f
    );
}

mat4 rotateZYX(vec3 rotation) {
    return rotateZ(rotation.z) * rotateY(rotation.y) * rotateX(rotation.x);
}

void main() {
    int index = int(gl_GlobalInvocationID.x);

    Pose result = entityBasePose.pose[index];

    int offset = animationOffsets.animationOffset[index];
    int   nextOffset = animationOffsets.animationOffset[index + 1];

    for (int i = 0; i < (nextOffset - offset); i++) {
        AnimationEntry animationEntry =  animation.animationEntries[offset+i];

        result.pose *= translate(animationEntry.position);

        result.pose *= translate(animationEntry.bonePivot);

        result.pose *= rotateZYX(animationEntry.rotation);

        result.pose = result.pose * scale(animationEntry.scale);

        result.pose *= translate(-animationEntry.bonePivot);
    }

    mat3 linearPart = mat3(result.pose);
    float det = determinant(linearPart);
    if (abs(det) > 1e-8) {
        result.normal = transpose(inverse(linearPart));
    } else {
        result.normal = mat3(1.0);
    }

    poses.pose[index]=result;
}
